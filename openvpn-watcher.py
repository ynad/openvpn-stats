#!/usr/bin/env python3

# Copyright 2024 Daniele Vercelli - ynad <info@danielevercelli.it>
# https://github.com/ynad/openvpn-stats
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 only.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>

"""
openvpn-watcher.py
2025-03-28
v0.0.5


OpenVPN-Watcher
Script to analyze OpenVPN stats and connection status.

Data is stored in a mongodb database for analysis, for which the MongoManager class is used.

Two working modes:
    (1) command line flag: '--log'
        Read short status file generated by openvpn server, showing current connections .
        Must be enabled in openvpn server config with option 'status openvpn-status.log' or custom path/filename.
        Equivalent to management console command 'status', option (2).

    (2) command line flag: '--console'
        Connect to the management console, either via TPC/IP or via Unix socket, and send commands.
        To gather short status report the command 'status' is used, equivalent to option (1).


Settings & credentials:
    * mongodb
        database connection settings and credentials must be provided in JSON format,
        by default in the file 'settings_database.json' as follows:
        {
            "ip" : "localhost",
            "port" : 27017,
            "db" : "openvpn_stats",
            "user" : "openvpn_stats_user",
            "pwd" : "openvpn_stats_password"
        }
        Values can be overridden via the following command line arguments: 
        db_ip (str), db_port (int), db (str), db_user (str), db_pw (str)

    * OpenVPN management console
        OpenVPN management console connection settings and credentials must be provided in JSON format,
        by default in the file 'settings_console.json' as follows:
        {
            "host" : "localhost",
            "port" : 5555,
            "password" : "console-password",
            "name" : "VPN-test"
        }
        Values can be overridden via the following command line arguments: 
        host (str), port (int), password (str), name (str)

Args:
    db_ip (str, default: None):                             IP address of mongodb server
    db_port (int, default: None):                           TCP port of mongodb server
    db (str, default: None):                                database name on mongodb server
    db_user (str, default: None):                           username for authentication to mongodb server
    db_pw (str, default: None):                             password for authentication to mongodb server
    mute (bool, default: False):                            Suppress info messages to stdout/stderr
    debug (bool, default: False):                           Enable debug messages to stdout/stderr
    loop (bool, default: False):                            Enable infinite loop mode, with default sleep wait time of 60 seconds
    wait (int, default: None):                              Custom sleep wait time between loops
    log (str, default: "/etc/openvpn/openvpn-status.log"):  Enable log file mode (1)
    console (bool, default: False):                         Enable console mode (2)
    host (str, default: 'localhost'):                       IP address where management console listen
    port (int, default: None):                              TCP port for management console
    password (str, default: None):                          Password used to access the console
    name (str, default: None):                              Name give to the OpenVPN instance

Requirements:
    * click

Custom required libraries:
    * mongo_manager (requires: pymongo)
    * openvpn_management (requires: regex)
"""


import json
import sys
import os
import logging
import signal
import click
from datetime import datetime, timedelta
from time import sleep

# custom libs import
from mongo_manager import MongoManager
from openvpn_management import OpenvpnManagement



logger = logging.getLogger(__name__)
logging.basicConfig(filename="./debug.log",
                    filemode='a',
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    #datefmt='%H:%M:%S',
                    level=logging.WARN)



# global settings
settings_database_json='settings_database.json'
settings_console_json='settings_console.json'



def signal_handler(signum: int, frame):
    print(f"SIGNAL {signum} received, exiting gracefully, at frame {frame}")
    logger.warning(f"SIGNAL {signum} received, exiting gracefully, at frame {frame}")
    sys.exit(0)


# load db credentials
def load_database_settings(settings_database_json: str) -> dict:
    if not os.path.exists(settings_database_json):
        logger.error(f"Missing database settings file: {settings_database_json}")
        raise Exception('Missing database settings file')

    logger.info("Loading database json settings from file: " + str(settings_database_json))
    with open(settings_database_json, 'r') as f:
        return json.load(f)


# load db credentials
def load_console_settings(settings_console_json: str) -> dict:
    if not os.path.exists(settings_console_json):
        logger.error(f"Missing console settings file: {settings_console_json}")
        raise Exception('Missing console settings file')

    logger.info("Loading console json settings from file: " + str(settings_console_json))
    with open(settings_console_json, 'r') as f:
        return json.load(f)


def read_status_file(status_file: str) -> list:
    try:
        # read file line by line
        with open(status_file, 'r') as fp:
            status_content = fp.readlines()
        return status_content

    except Exception as exc:
        print(f"Error reading status file: {status_file}, cannot continue")
        raise Exception(f"Error reading status file: {status_file}") from exc


def parse_status(status_content: list, mute: bool) -> None:
    client_section = False
    routes_section = False
    stats_time = None
    clients_list = {}

    for line in status_content:
        this_line = line.rstrip()

        # stats time
        if this_line.startswith('Updated'):
            stats_time = this_line.split(',')[1]
            if not mute:
                print(f"Status time: {stats_time}")
            continue

        # trigger clients section
        if this_line.startswith('Common Name'):
            if not mute:
                print("Clients section")
            client_section = True
            continue

        # trigger routing section
        if this_line == "ROUTING TABLE":
            client_section = False
            if not clients_list:
                if not mute:
                    print("No clients connected")
            else:
                if not mute:
                    print("Routing section")
                routes_section = True
            continue

        if this_line.startswith('Virtual Address'):
            continue

        if this_line.startswith('GLOBAL'):
            continue

        if this_line.startswith('Max bcast'):
            continue

        # trigger clients section
        if this_line == "END":
            if not mute:
                print("END OF STATUS\n")
            break

        # parse this as client line
        if client_section:
            client_line = this_line.split(',')
            client_cname = client_line[0]
            client_ip = client_line[1].split(':')[0]
            client_port = client_line[1].split(':')[1]
            byte_rec = client_line[2]
            byte_sent = client_line[3]
            conn_time = client_line[4]
            conn_start = datetime.strptime(conn_time, '%Y-%m-%d %H:%M:%S')
            conn_day = conn_start.strftime('%Y.%m.%d')

            client = {
                'id' : client_cname,
                'ip' : client_ip,
                'port' : client_port,
                'bytes' : {
                    'received' : int(byte_rec),
                    'sent' : int(byte_sent)
                },
                'date' : conn_day,
                'start' : conn_start
            }
            clients_list[client_cname] = client
            if not mute:
                print(f"Connected client: {client_cname}, on day: {conn_day} from IP: {client_ip}:{client_port}, byte received: {byte_rec}, byte sent: {byte_sent}, start time: {conn_time}")

        # parse this as routing line
        if routes_section:
            route_line = this_line.split(',')

            ip_virt = route_line[0]
            client_cname = route_line[1]
            ip_real = route_line[2]
            last_conn = route_line[3]
            client_datetime = datetime.strptime(last_conn, '%Y-%m-%d %H:%M:%S')

            if client_cname in clients_list:
                # workaround for DCO breaking last ping time ~equal to start connection time
                # use stats time instead, which is likely closer to real last ping time
                if (client_datetime - clients_list[client_cname]['start']) < timedelta(seconds=10):
                    logger.info(f"workaround DCO, using stats_time {stats_time}, instead of bogus client_datetime: {client_datetime}")
                    last_conn = stats_time
                    client_datetime = datetime.strptime(stats_time, '%Y-%m-%d %H:%M:%S')

                conn_seconds = client_datetime - clients_list[client_cname]['start']
                clients_list[client_cname]['last'] = client_datetime
                clients_list[client_cname]['seconds'] = int(conn_seconds.total_seconds())

            else:
                if not mute:
                    print(f"Cannot add route seconds, missing cname in clients_list: {client_cname}")

            if not mute:
                print(f"Route client: {client_cname}, virtual IP: {ip_virt}, real IP: {ip_real}, last ping: {last_conn}, connection time: {conn_seconds}")

    try:
        for cname, client in clients_list.items():
            res, msg = mongo_client.connection_log(client)
            if not mute:
                print(f"DB update connection_log: {res}, notice: {msg}")

    except Exception as exc:
        print(f"Error on db operation, connection_log data may not be recorded: {str(exc)}")



@click.command()
@click.option(
    "--db_ip",
    type=str,
    default=""
)
@click.option(
    "--db_port",
    type=int,
    #default=27017
)
@click.option(
    "--db",
    type=str,
    default=""
)
@click.option(
    "--db_user",
    type=str,
    default=""
)
@click.option(
    "--db_pw",
    type=str,
    default=""
)
@click.option(
    "--mute",
    is_flag=True
)
@click.option(
    "--debug",
    is_flag=True
)
@click.option(
    "--loop",
    is_flag=True
)
@click.option(
    "--wait",
    type=int,
    #default=""
)
@click.option(
    "--log",
    type=str,
    default="/etc/openvpn/openvpn-status.log"
)
@click.option(
    "--console",
    is_flag=True
)
@click.option(
    "--host",
    type=str,
    default="127.0.0.1"
)
@click.option(
    "--port",
    type=int,
    default=5555
)
@click.option(
    "--password",
    type=str,
    default=""
)
@click.option(
    "--name",
    type=str,
    default=""
)



## Main
def main(db_ip: str, db_port: int, db: str, db_user: str, db_pw: str,   # database parameters
        mute: bool, debug: bool, loop: bool, wait: int,                 # misc settings
        log: str,                                                       # status via log file
        console: bool, host: str, port: int, password: str, name: str,  # status via console connection to OpenVPN management interface          
    ):

    global mongo_client

    # load db settings
    db_settings = load_database_settings(settings_database_json)
    db_ip = db_ip if db_ip else db_settings['ip']
    db_port = db_port if db_port else db_settings['port']
    db = db if db else db_settings['db']
    db_user = db_user if db_user else db_settings['user']
    db_pw = db_pw if db_pw else db_settings['pwd']


    # Register the signal handler
    signal.signal(signal.SIGTERM, signal_handler)

    # start mongo handler
    mongo_client = MongoManager(db_ip, db_port, db, username=db_user, password=db_pw)


    if not mute:
        print(f"=== OpenVPN-stats ===")

    # custom sleep time
    if wait:
        try:
            loop = True
            sleep_t = int(wait)
            assert sleep_t > 0 and sleep_t < 86401
            if not mute:
                print(f"Sleep time set to: {sleep_t}\n")

        except (ValueError, AssertionError):
            print(f"Wrong wait time value, must be an integer expressing seconds between 1s and 24h: {wait}")
            raise ValueError('Wrong wait time value')

    # default loop wait time
    elif loop:
        sleep_t = 60
        if not mute:
            print(f"Sleep time default: {sleep_t}\n")

    # single run
    else:
        if not mute:
            print("Single run\n")


    # openvpn management interface via console
    if console:
        console_settings = load_console_settings(settings_console_json)
        sck_host = host if host else console_settings['host']
        sck_port = port if port else console_settings['port']
        sck_password = password if password else console_settings['password']
        sck_name = name if name else console_settings['name']

        # openvpn management interface
        ovpn_manag = OpenvpnManagement(host=sck_host,
                                       port=sck_port,
                                       password=sck_password,
                                       name=sck_name,
                                       mute=mute,
                                       debug=debug
                            )
        try:
            # loop
            while True:
                # connect socket
                ovpn_manag.socket_connect()

                # get status via socket
                status_content = ovpn_manag.send_command('status\n')
                
                # parse status content, log eventual data
                parse_status(status_content.splitlines(), mute)

                # break while on single run
                if not loop:
                    break

                # sleep between while loop
                sleep(sleep_t)

        except KeyboardInterrupt:
            if not mute:
                print("KeyboardInterrupt received")
            logger.warning("KeyboardInterrupt received")

        except Exception as exc:
            print(f"Exception in console mode: {repr(exc)}")
            logger.warning(f"Exception in console mode: {repr(exc)}")

        finally:
            # close socket
            ovpn_manag.socket_disconnect()


    # status file
    else:
        # check existance of status file
        logfile = log
        if not os.path.exists(logfile):
            print(f"Status file not found: {logfile}")
            raise FileNotFoundError(logfile)

        try:
            # loop
            while True:
                # read status from file
                status_content = read_status_file(logfile)

                # parse status content, log eventual data
                parse_status(status_content, mute)

                # break while on single run
                if not loop:
                    break

                # sleep between while loop
                sleep(sleep_t)

        except KeyboardInterrupt:
            if not mute:
                print("KeyboardInterrupt received")
            logger.warning("KeyboardInterrupt received")

        except Exception as exc:
            print(f"Exception in status file mode: {repr(exc)}")
            logger.warning(f"Exception in status file mode: {repr(exc)}")



if __name__ == '__main__':
    main()

